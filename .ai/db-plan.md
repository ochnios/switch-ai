# Database schema description - switch-ai (MVP)

## 1. Lista tabel z ich kolumnami, typami danych i ograniczeniami

### Typy niestandardowe

#### Enum: `message_role`

Definiuje zbiór dozwolonych wartości dla roli przypisanej do wiadomości. Wartości: 'user', 'assistant', 'system'.

### Tabela: `api_keys`

Przechowuje zaszyfrowane klucze API OpenRouter należące do użytkowników.

* id (UUID, PRIMARY KEY, DEFAULT gen\_random\_uuid())
* user\_id (UUID, FOREIGN KEY -> auth.users.id, UNIQUE, NOT NULL, ON DELETE CASCADE)
* encrypted\_key (TEXT, NOT NULL)
* created\_at (TIMESTAMPTZ, NOT NULL, DEFAULT now())

### Tabela: `conversations`

Przechowuje metadane dla każdej konwersacji, w tym jej tytuł i relacje z innymi konwersacjami (rozgałęzienia).

* id (UUID, PRIMARY KEY, DEFAULT gen\_random\_uuid())
* user\_id (UUID, FOREIGN KEY -> auth.users.id, NOT NULL, ON DELETE CASCADE)
* parent\_conversation\_id (UUID, FOREIGN KEY -> conversations.id, ON DELETE SET NULL)
* title (TEXT)
* branch\_count (INTEGER, NOT NULL, DEFAULT 0)
* created\_at (TIMESTAMPTZ, NOT NULL, DEFAULT now())

### Tabela: `messages`

Przechowuje zawartość każdej pojedynczej wiadomości w ramach konwersacji.

* id (BIGINT, PRIMARY KEY, GENERATED BY DEFAULT AS IDENTITY)
* conversation\_id (UUID, FOREIGN KEY -> conversations.id, NOT NULL, ON DELETE CASCADE)
* role (message\_role, NOT NULL)
* content (TEXT, NOT NULL)
* model\_name (TEXT)
* prompt\_tokens (INTEGER)
* completion\_tokens (INTEGER)
* created\_at (TIMESTAMPTZ, NOT NULL, DEFAULT now())

## 2. Relacje między tabelami

* auth.users - api\_keys (1-1): Każdy użytkownik może posiadać dokładnie jeden klucz API.
* auth.users - conversations (1-n): Użytkownik może utworzyć wiele konwersacji, ale każda konwersacja należy do jednego użytkownika.
* conversations - messages (1-n): Konwersacja składa się z wielu wiadomości, ale każda wiadomość należy do jednej konwersacji.
* conversations - conversations (1-n, samoodwołanie): Konwersacja może być rodzicem dla wielu innych konwersacji (gałęzi), co jest zrealizowane przez klucz obcy `parent_conversation_id`.

## 3. Indeksy

### idx\_conversations\_user\_id

Tabela: `conversations`
Kolumna: `user_id`
Cel: Przyspieszenie zapytań filtrujących konwersacje dla zalogowanego użytkownika.

### idx\_messages\_conversation\_id\_created\_at

Tabela: `messages`
Kolumny: `conversation_id`, `created_at` (DESC)
Cel: Optymalizacja najczęstszego zapytania, czyli pobierania pełnej, posortowanej historii wiadomości dla pojedynczej konwersacji.

## 4. Zasady PostgreSQL (Row-Level Security)

Zabezpieczenia na poziomie wiersza (RLS) są włączone dla tabel `api_keys`, `conversations` i `messages` w celu zapewnienia ścisłej izolacji danych między użytkownikami.

* Zasada dla `api_keys`: Użytkownicy mogą tworzyć, odczytywać, aktualizować i usuwać wyłącznie własny klucz API.
* Zasada dla `conversations`: Użytkownicy mogą tworzyć, odczytywać, aktualizować i usuwać wyłącznie własne konwersacje.
* Zasada dla `messages`: Użytkownicy mogą zarządzać wiadomościami (wszystkie operacje CRUD) tylko wtedy, gdy są właścicielami konwersacji, do której te wiadomości należą.

## 5. Wszelkie dodatkowe uwagi lub wyjaśnienia dotyczące decyzji projektowych

* Zarządzanie użytkownikami: Tabela `users` nie jest częścią tego schematu, ponieważ jest dostarczana i zarządzana przez system Supabase Auth. Wszystkie relacje są budowane w oparciu o tabelę `auth.users`.
* Szyfrowanie: Kolumna `encrypted_key` w tabeli `api_keys` przechowuje zaszyfrowaną wartość. Proces szyfrowania i deszyfrowania jest realizowany po stronie backendu, np. przy użyciu rozszerzenia `pgsodium` w Supabase, aby klucz w postaci jawnej nigdy nie był narażony na nieautoryzowany dostęp.
* Integralność danych przy usuwaniu: Usunięcie użytkownika powoduje kaskadowe usunięcie jego klucza API oraz wszystkich jego konwersacji i wiadomości. Usunięcie konwersacji nadrzędnej nie usuwa jej gałęzi – zamiast tego zrywa powiązanie, ustawiając `parent_conversation_id` na `NULL`.
* Licznik gałęzi: Kolumna `branch_count` w tabeli `conversations` służy jako prosty i wydajny licznik, który eliminuje potrzebę wykonywania dodatkowych zapytań agregujących przy tworzeniu nowej gałęzi i generowaniu jej nazwy.
